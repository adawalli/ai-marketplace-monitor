{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Add python-telegram-bot dependency",
        "description": "Add the python-telegram-bot library as a project dependency using uv",
        "details": "Add `python-telegram-bot>=20.0` to pyproject.toml dependencies. Use `uv add python-telegram-bot` to install the latest stable version. This library provides async Telegram Bot API wrapper with automatic API updates and comprehensive error handling. Version 20+ includes improved asyncio support and MarkdownV2 formatting helpers required for safe message formatting.",
        "testStrategy": "Verify dependency installation with `uv sync` and confirm import works with `python -c 'import telegram; print(telegram.__version__)'`. Check that version is 20.0 or higher for required features.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add python-telegram-bot dependency to pyproject.toml",
            "description": "Add the python-telegram-bot library version 20.0 or higher as a dependency in the pyproject.toml file using uv package manager.",
            "dependencies": [],
            "details": "Modify pyproject.toml to include `python-telegram-bot>=20.0` under dependencies. Use the command `uv add python-telegram-bot` to install the latest stable version. This ensures the project uses the async Telegram Bot API wrapper with improved asyncio support and MarkdownV2 formatting helpers.",
            "status": "done",
            "testStrategy": "Verify installation by running `uv sync` and confirm the package is installed with `python -c 'import telegram; print(telegram.__version__)'`. Ensure the version is 20.0 or higher."
          },
          {
            "id": 2,
            "title": "Create TelegramNotificationConfig class",
            "description": "Implement a configuration class TelegramNotificationConfig extending PushNotificationConfig with Telegram-specific fields.",
            "dependencies": [],
            "details": "Create TelegramNotificationConfig in notification.py with fields `telegram_token` (str) and `telegram_chat_id` (str). Set `required_fields` to include these fields. Implement validation methods: `handle_telegram_token()` to check token format (numbers followed by colon) and `handle_telegram_chat_id()` to validate chat ID format (numeric string or username). Follow patterns from existing PushbulletNotificationConfig and PushoverNotificationConfig classes.",
            "status": "done",
            "testStrategy": "Unit tests to verify field validation, required fields enforcement, and inheritance correctness. Test invalid token and chat ID formats raise validation errors."
          },
          {
            "id": 3,
            "title": "Implement _send_message_async method using telegram.Bot",
            "description": "Create a private asynchronous method to send messages using telegram.Bot with proper error handling and MarkdownV2 formatting.",
            "dependencies": [],
            "details": "Implement `_send_message_async(title, message, logger)` method that creates a telegram.Bot instance per call using `telegram.Bot(token=self.telegram_token)`. Send messages with `bot.send_message(chat_id=self.telegram_chat_id, text=formatted_message, parse_mode='MarkdownV2')`. Format message as `*{title}*\n\n{message}` with MarkdownV2 escaping. Handle `telegram.error.TelegramError` exceptions and log errors appropriately.",
            "status": "done",
            "testStrategy": "Unit tests using AsyncMock for telegram.Bot. Mock `send_message()` to verify correct parameters and parse_mode. Test exception handling for common Telegram errors (401, 400, 403)."
          },
          {
            "id": 4,
            "title": "Implement safe MarkdownV2 formatting with escape_markdown",
            "description": "Use telegram.helpers.escape_markdown to safely escape user-generated content before sending messages to Telegram.",
            "dependencies": [],
            "details": "Import `telegram.helpers.escape_markdown` and apply it to message titles and bodies to escape special MarkdownV2 characters (_ * [ ] ( ) ~ ` > # + - = | { } . !). Format the final message as `*{escape_markdown(title, version=2)}*\n\n{escape_markdown(message, version=2)}` ensuring the title is bolded after escaping.",
            "status": "done",
            "testStrategy": "Unit tests with various special characters in titles and messages. Verify escaping prevents Telegram API errors. Test edge cases including messages with only special characters or markdown-like syntax."
          },
          {
            "id": 5,
            "title": "Verify dependency installation and import correctness",
            "description": "Confirm that the python-telegram-bot dependency is correctly installed and can be imported with the required version.",
            "dependencies": [],
            "details": "Run `uv sync` to synchronize dependencies. Execute `python -c 'import telegram; print(telegram.__version__)'` to verify the package is importable and the version is 20.0 or higher, ensuring compatibility with async features and MarkdownV2 helpers.",
            "status": "done",
            "testStrategy": "Automated or manual verification of import success and version check. Fail the task if import fails or version is below 20.0."
          }
        ]
      },
      {
        "id": 2,
        "title": "Create TelegramNotificationConfig class",
        "description": "Implement TelegramNotificationConfig extending PushNotificationConfig with Telegram-specific fields",
        "details": "Create class in notification.py extending PushNotificationConfig. Add fields: telegram_token (str), telegram_chat_id (str). Set required_fields = ['telegram_token', 'telegram_chat_id']. Implement validation handlers: handle_telegram_token() to validate bot token format (should start with numbers followed by colon), handle_telegram_chat_id() to validate chat ID format (numeric string or username). Follow exact pattern of existing PushbulletNotificationConfig and PushoverNotificationConfig classes.",
        "testStrategy": "Unit tests for field validation, required_fields checking, and proper inheritance from PushNotificationConfig. Test invalid token/chat_id formats raise appropriate validation errors.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TelegramNotificationConfig class extending PushNotificationConfig",
            "description": "Create the TelegramNotificationConfig class in notification.py that inherits from PushNotificationConfig.",
            "dependencies": [],
            "details": "Implement the class definition following Python OOP conventions. Use the class keyword and ensure proper inheritance from PushNotificationConfig. Follow the pattern of existing PushbulletNotificationConfig and PushoverNotificationConfig classes for structure and style.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Add Telegram-specific fields and required_fields attribute",
            "description": "Add telegram_token and telegram_chat_id fields as strings to TelegramNotificationConfig and set required_fields accordingly.",
            "dependencies": [],
            "details": "Define telegram_token and telegram_chat_id as string attributes. Set the class attribute required_fields to ['telegram_token', 'telegram_chat_id'] to enforce mandatory configuration.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement validation handlers for telegram_token and telegram_chat_id",
            "description": "Create handle_telegram_token() and handle_telegram_chat_id() methods to validate the formats of the Telegram bot token and chat ID.",
            "dependencies": [],
            "details": "handle_telegram_token() should verify the token starts with numbers followed by a colon. handle_telegram_chat_id() should validate that the chat ID is either a numeric string or a valid username. Follow validation patterns used in PushbulletNotificationConfig and PushoverNotificationConfig.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement synchronous send_message method using asyncio.run()",
            "description": "Add a send_message(title, message, logger) method that synchronously calls an async message sending method using asyncio.run().",
            "dependencies": [],
            "details": "Implement send_message to call a private async method _send_message_async() via asyncio.run(). Handle exceptions by logging errors and wrapping them in notification exceptions. Ensure method signature matches the base class exactly.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement private async _send_message_async method using telegram.Bot",
            "description": "Create the _send_message_async(title, message, logger) method that sends messages using telegram.Bot with proper formatting and error handling.",
            "dependencies": [],
            "details": "Instantiate telegram.Bot with telegram_token. Use bot.send_message with chat_id=telegram_chat_id, formatted message text with MarkdownV2 escaping, and parse_mode='MarkdownV2'. Handle telegram.error.TelegramError exceptions and log errors appropriately.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Implement sync send_message wrapper method",
        "description": "Create synchronous send_message method that uses asyncio.run() to call async Telegram operations",
        "details": "Implement send_message(title, message, logger) method in TelegramNotificationConfig. Use asyncio.run() pattern to call private _send_message_async() method. Handle any asyncio-related exceptions and wrap them in appropriate notification exceptions. Ensure method signature matches base class exactly. Pattern: `def send_message(self, title, message, logger): try: asyncio.run(self._send_message_async(title, message, logger)) except Exception as e: logger.error(f'Telegram notification failed: {e}'); raise`",
        "testStrategy": "Unit tests using AsyncMock to mock _send_message_async. Verify asyncio.run() is called correctly and exceptions are properly wrapped. Test with both successful and failing async operations.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define synchronous send_message method with asyncio.run()",
            "description": "Implement the synchronous send_message(title, message, logger) method in TelegramNotificationConfig that calls the private async method _send_message_async using asyncio.run().",
            "dependencies": [],
            "details": "Create send_message method matching the base class signature exactly. Use try-except to call asyncio.run(self._send_message_async(title, message, logger)) and catch any exceptions. Log errors with logger.error and raise appropriate notification exceptions to wrap asyncio-related errors.",
            "status": "done",
            "testStrategy": "Unit tests to verify asyncio.run() is called correctly, exceptions are caught and wrapped, and logger.error is invoked on failure."
          },
          {
            "id": 2,
            "title": "Implement private async _send_message_async method using telegram.Bot",
            "description": "Create the private asynchronous method _send_message_async(title, message, logger) that sends messages using telegram.Bot with proper MarkdownV2 formatting.",
            "dependencies": [
              "3.1"
            ],
            "details": "Instantiate telegram.Bot with the configured token per call. Format the message as '*{title}*\\n\\n{message}' with MarkdownV2 escaping. Use bot.send_message(chat_id=self.telegram_chat_id, text=formatted_message, parse_mode='MarkdownV2'). Handle telegram.error.TelegramError exceptions and log errors appropriately.",
            "status": "done",
            "testStrategy": "Unit tests with AsyncMock for telegram.Bot and bot.send_message. Verify correct parameters and exception handling for common Telegram errors."
          },
          {
            "id": 3,
            "title": "Add safe MarkdownV2 escaping for user content",
            "description": "Integrate telegram.helpers.escape_markdown to safely escape user-generated content in titles and messages before sending.",
            "dependencies": [
              "3.2"
            ],
            "details": "Import escape_markdown and apply it to title and message with version=2 before formatting. Ensure escaping covers all special MarkdownV2 characters. Apply bold formatting to escaped title only after escaping. This prevents Telegram API errors due to unescaped characters.",
            "status": "done",
            "testStrategy": "Unit tests with various special characters and markdown-like syntax in titles and messages. Verify escaping prevents errors and preserves intended formatting."
          },
          {
            "id": 4,
            "title": "Implement exception handling and wrapping in send_message",
            "description": "Enhance send_message to catch asyncio and Telegram-related exceptions from _send_message_async and wrap them in appropriate notification exceptions.",
            "dependencies": [
              "3.1",
              "3.2",
              "3.3"
            ],
            "details": "Within send_message, catch all exceptions from asyncio.run call. Log the error message using logger.error with a clear prefix. Raise custom notification exceptions that encapsulate the original error to provide meaningful error context to callers.",
            "status": "done",
            "testStrategy": "Unit tests simulating exceptions thrown by _send_message_async. Verify logger.error is called and exceptions are wrapped and re-raised correctly."
          },
          {
            "id": 5,
            "title": "Verify method signature compliance and integration",
            "description": "Ensure the implemented send_message method signature exactly matches the base class definition and integrates correctly within TelegramNotificationConfig.",
            "dependencies": [
              "3.1",
              "3.4"
            ],
            "details": "Check that send_message accepts parameters (title, message, logger) with no deviations. Confirm that the method integrates seamlessly with the rest of the notification system and respects expected behavior and error handling patterns.",
            "status": "done",
            "testStrategy": "Static code analysis and unit tests verifying method signature. Integration tests to confirm correct operation within the notification framework."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement telegram.Bot direct integration",
        "description": "Create private async method using telegram.Bot class for simple message sending",
        "details": "Implement _send_message_async(title, message, logger) method using telegram.Bot(token=self.telegram_token). Use bot.send_message(chat_id=self.telegram_chat_id, text=formatted_message, parse_mode='MarkdownV2'). Create bot instance per call for simple lifecycle management. Handle telegram.error.TelegramError exceptions and log appropriately. Format message as: `*{title}*\\n\\n{message}` with proper MarkdownV2 escaping.",
        "testStrategy": "Unit tests with AsyncMock for telegram.Bot. Mock bot.send_message() and verify correct parameters (chat_id, text, parse_mode). Test exception handling for common Telegram errors (401, 400, 403).",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create bot instance and format message",
            "description": "Implement logic to create a new telegram.Bot instance per call using the provided telegram_token. Format the message string as '*{title}*\\n\\n{message}' with proper MarkdownV2 escaping.",
            "dependencies": [],
            "details": "Use telegram.Bot(token=self.telegram_token) to instantiate the bot. Format the message by escaping special MarkdownV2 characters in title and message, then apply bold formatting to the title as '*{escaped_title}*\\n\\n{escaped_message}'.",
            "status": "done",
            "testStrategy": "Unit tests verifying correct bot instantiation and message formatting with various special characters."
          },
          {
            "id": 2,
            "title": "Implement async _send_message_async method",
            "description": "Develop the private asynchronous method _send_message_async(title, message, logger) that sends the formatted message using bot.send_message with parse_mode='MarkdownV2'.",
            "dependencies": [
              "4.1"
            ],
            "details": "Within _send_message_async, create the bot instance, send the message to telegram_chat_id using bot.send_message(chat_id=self.telegram_chat_id, text=formatted_message, parse_mode='MarkdownV2'), and ensure the method is async.",
            "status": "done",
            "testStrategy": "Unit tests with AsyncMock to verify bot.send_message is called with correct parameters."
          },
          {
            "id": 3,
            "title": "Handle telegram.error.TelegramError exceptions",
            "description": "Add exception handling in _send_message_async to catch telegram.error.TelegramError exceptions and log errors appropriately using the provided logger.",
            "dependencies": [
              "4.2"
            ],
            "details": "Wrap the send_message call in try-except to catch TelegramError exceptions. Log error details with logger.error to aid debugging and monitoring.",
            "status": "done",
            "testStrategy": "Unit tests simulating TelegramError exceptions to verify proper logging and error handling."
          },
          {
            "id": 4,
            "title": "Ensure bot lifecycle management per call",
            "description": "Manage the lifecycle of the telegram.Bot instance by creating and disposing it within each call to _send_message_async to avoid persistent state issues.",
            "dependencies": [
              "4.3"
            ],
            "details": "Create the bot instance inside the method scope and allow it to be garbage collected after the message is sent, ensuring no shared state or resource leaks.",
            "status": "done",
            "testStrategy": "Code review and runtime checks to confirm no persistent bot instances remain after method execution."
          },
          {
            "id": 5,
            "title": "Write unit tests for _send_message_async",
            "description": "Develop comprehensive unit tests for _send_message_async covering message formatting, bot instantiation, successful message sending, and exception handling.",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "Use AsyncMock to mock telegram.Bot and its send_message method. Test correct parameters, MarkdownV2 escaping, exception handling for TelegramError, and lifecycle management.",
            "status": "done",
            "testStrategy": "Automated unit tests verifying all functional aspects and error scenarios of _send_message_async."
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement safe MarkdownV2 formatting",
        "description": "Add telegram.helpers.escape_markdown for safe user content formatting",
        "details": "Import telegram.helpers.escape_markdown and use it to escape user-generated content before sending. MarkdownV2 requires escaping: _ * [ ] ( ) ~ ` > # + - = | { } . ! characters. Apply escaping to listing titles, descriptions, and any user data. Format final message as: `*{escape_markdown(title, version=2)}*\\n\\n{escape_markdown(message, version=2)}`. Ensure title formatting (*bold*) is applied after escaping.",
        "testStrategy": "Unit tests with various special characters in titles and messages. Verify proper escaping prevents Telegram API errors. Test edge cases like messages containing only special characters or markdown-like syntax.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Integrate telegram.helpers.escape_markdown for user content",
            "description": "Import and apply telegram.helpers.escape_markdown with version=2 to escape all user-generated content including listing titles, descriptions, and messages before sending. Ensure escaping covers all MarkdownV2 special characters and that title formatting (bold) is applied after escaping.",
            "dependencies": [],
            "details": "Modify the message formatting logic in _send_message_async to use escape_markdown(text, version=2) on all user content. Confirm that the final message format is '*{escaped_title}*\\n\\n{escaped_message}'. Verify that all special characters (_ * [ ] ( ) ~ ` > # + - = | { } . !) are properly escaped to prevent Telegram API errors.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Write unit tests covering special characters and edge cases",
            "description": "Develop comprehensive unit tests to verify correct escaping of all MarkdownV2 special characters and edge cases such as messages containing only special characters or markdown-like syntax. Ensure tests confirm that escaped messages do not cause Telegram API errors.",
            "dependencies": [
              "5.1"
            ],
            "details": "Create test cases with titles and messages containing various special characters, combinations, and edge cases. Use mocks to simulate sending messages and verify that escape_markdown is applied correctly and that the formatted message matches expected escaped output. Include tests for empty strings, very long strings, and strings with nested markdown-like patterns.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Add Telegram config to User model",
        "description": "Extend user configuration loading to support Telegram notification settings",
        "details": "Modify config.py to include telegram_token and telegram_chat_id in User model configuration loading. Add these fields to user configuration parsing in load_user_config(). Ensure TelegramNotificationConfig is instantiated when telegram_token is present in user config. Follow existing pattern used for pushbullet_token, pushover_token, etc. Add to notification_configs list when valid Telegram config is found.",
        "testStrategy": "Unit tests for config loading with telegram fields present and absent. Verify TelegramNotificationConfig is created correctly from TOML config. Test validation errors for invalid telegram configurations.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Modify User model and config loading to include Telegram fields",
            "description": "Update config.py to add telegram_token and telegram_chat_id fields to the User model configuration loading. Extend load_user_config() to parse these new Telegram fields from the user config file.",
            "dependencies": [],
            "details": "Follow the existing pattern used for other notification tokens like pushbullet_token and pushover_token. Ensure the User model can hold telegram_token and telegram_chat_id attributes and that these are correctly loaded from the TOML config.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Instantiate TelegramNotificationConfig when Telegram config is present",
            "description": "Modify the configuration loading logic to instantiate a TelegramNotificationConfig object when telegram_token is present in the user config. Add this instance to the notification_configs list if valid.",
            "dependencies": [
              "6.1"
            ],
            "details": "Use the TelegramNotificationConfig class implemented in Task 2. Ensure that the instantiation and validation follow the existing pattern for other notification configs. Only create the instance if telegram_token and telegram_chat_id are both present and valid.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Unit test config parsing and validation for Telegram fields",
            "description": "Write unit tests to verify that the user config loading correctly parses telegram_token and telegram_chat_id fields. Test that TelegramNotificationConfig is instantiated properly when config is valid and that validation errors are raised for invalid Telegram config.",
            "dependencies": [
              "6.1",
              "6.2"
            ],
            "details": "Include tests for presence and absence of Telegram fields in the config. Validate that invalid token formats and chat IDs trigger appropriate validation errors. Follow the test strategy used for other notification configs.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement message splitting for 4096 character limit",
        "description": "Handle Telegram's message length limit by splitting long messages",
        "details": "Implement message splitting logic in _send_message_async() to handle Telegram's 4096 character limit. Split at word boundaries when possible, preserving MarkdownV2 formatting. Send multiple messages if content exceeds limit. Add continuation indicators like '(1/3)', '(2/3)' for multi-part messages. Ensure title formatting is preserved in first message only. Handle edge cases where single words exceed limit.",
        "testStrategy": "Unit tests with messages of various lengths (under limit, slightly over, significantly over). Verify splitting preserves formatting and sends multiple messages in sequence. Test edge cases with very long words or URLs.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement splitting logic respecting word boundaries",
            "description": "Develop the core logic to split messages into parts without breaking words, ensuring each part is within the 4096 character limit.",
            "dependencies": [],
            "details": "Analyze the message text and split it at spaces or other word boundaries to avoid cutting words in half. Ensure that each split message part does not exceed Telegram's 4096 character limit.\n<info added on 2025-07-31T23:52:19.295Z>\nImplementation complete: Added _split_message_at_boundaries() method to TelegramNotificationConfig that intelligently splits messages at word boundaries while respecting the 4096 character limit. The method handles edge cases where individual words exceed the limit by force-splitting at the boundary. Modified _send_message_async() to detect oversized messages and automatically split them, with the first message containing the title and (1/n) indicator, and subsequent messages using continuation indicators (2/n), (3/n), etc. The splitting logic preserves message integrity and maintains proper formatting structure across all message parts.\n</info added on 2025-07-31T23:52:19.295Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Preserve MarkdownV2 formatting across splits",
            "description": "Ensure that MarkdownV2 formatting is correctly maintained and valid in each split message part.",
            "dependencies": [
              "7.1"
            ],
            "details": "Handle MarkdownV2 escape sequences and formatting tags so that they are not broken across message splits. Maintain proper escaping and formatting consistency in all message parts.\n<info added on 2025-07-31T23:59:50.448Z>\nTask completed successfully. Implementation uses split-then-escape approach: splits original unescaped message at word boundaries first, then applies telegram.helpers.escape_markdown to each part individually. This prevents breaking MarkdownV2 escape sequences and formatting tags during splitting. Added comprehensive unit tests covering formatting preservation, escape sequence integrity, original vs escaped message splitting, and individual part escaping. All 42 tests passing with proper MarkdownV2 handling maintained across all message parts.\n</info added on 2025-07-31T23:59:50.448Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add continuation indicators for multi-part messages",
            "description": "Append continuation indicators like '(1/3)', '(2/3)' to each message part to indicate the sequence and total number of parts.",
            "dependencies": [
              "7.1",
              "7.2"
            ],
            "details": "Design and add continuation markers at the end or beginning of each split message to clearly show the order and total count of message parts, improving readability and user experience.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Handle edge cases such as very long words exceeding limit",
            "description": "Implement logic to manage edge cases where single words or URLs exceed the 4096 character limit and cannot be split at word boundaries.",
            "dependencies": [
              "7.1"
            ],
            "details": "Detect words longer than the limit and apply fallback splitting strategies, such as forced splitting or truncation, while preserving as much formatting as possible.\n<info added on 2025-08-01T18:43:52.489Z>\nImplementation complete and verified through comprehensive testing. Edge case handling for extremely long words, URLs, and character sequences is working correctly via the force-splitting mechanism in _split_message_at_boundaries() method (lines 346-348). When no word boundary is found within the 4096 limit, the method force-splits at max_length to handle any content that exceeds the character limit.\n\nComprehensive test coverage added in test_split_message_extreme_edge_cases() validating:\n- 5000+ character URLs with proper force-splitting and content preservation\n- Multiple extremely long words handled individually\n- 10,000 character single-character strings split into correct 4096-char chunks\n- Content integrity verification through rejoining split message parts\n\nAll 43 Telegram notification tests pass, confirming robust handling of any message length or word size while maintaining MarkdownV2 formatting and continuation indicators.\n</info added on 2025-08-01T18:43:52.489Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Telegram rate limiting and 429 handling",
        "description": "Add rate limiting support with proper handling of Telegram API rate limits",
        "details": "Implement rate limiting in _send_message_async(): 1 message/second per chat, 20/minute for groups, 30/second global limit. Handle HTTP 429 'Too Many Requests' responses by reading Retry-After header and waiting appropriately. Use asyncio.sleep() for backoff delays. Add retry logic with exponential backoff for rate limit errors. Track message timestamps to avoid hitting limits proactively.",
        "testStrategy": "Unit tests mocking 429 responses with various Retry-After values. Verify proper sleep delays and retry behavior. Test rate limiting logic with different chat types and message frequencies.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Enhance error handling and logging",
        "description": "Add comprehensive error handling for Telegram-specific failures",
        "details": "Enhance _send_message_async() with specific error handling for common Telegram errors: 401 Unauthorized (invalid token), 400 Bad Request (invalid chat_id), 403 Forbidden (bot blocked), 404 Not Found (chat not found). Add detailed logging with actionable error messages. Map telegram.error exceptions to appropriate NotificationError types. Include troubleshooting hints in error messages (e.g., 'Check bot token from @BotFather').",
        "testStrategy": "Unit tests for each error type with appropriate exception mocking. Verify error messages contain helpful troubleshooting information. Test error mapping to existing notification error hierarchy.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Add comprehensive unit tests with AsyncMock",
        "description": "Create full test coverage for Telegram notification functionality using AsyncMock",
        "details": "Create test_telegram_notification.py following existing test patterns. Use AsyncMock from unittest.mock for async function testing. Test scenarios: successful message sending, various error conditions, message splitting, rate limiting, configuration validation. Mock telegram.Bot and all async operations. Ensure 100% code coverage for TelegramNotificationConfig class. Follow existing test patterns from test_pushbullet_notification.py.",
        "testStrategy": "Run tests with `uv run invoke tests` and verify 100% coverage for Telegram notification code. Use pytest-asyncio is not required since we're testing sync interfaces that internally use asyncio.run(). Validate all edge cases and error conditions are covered.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Create user setup documentation",
        "description": "Write comprehensive user guide for Telegram bot setup and configuration",
        "details": "Create documentation in README.md or separate guide covering: 1) Creating bot via @BotFather on Telegram, 2) Obtaining bot token, 3) Finding chat ID using @userinfobot or API calls, 4) Adding telegram_token and telegram_chat_id to user config, 5) Testing configuration. Include troubleshooting section for common errors (401, 403, 400). Add configuration examples and screenshots if helpful.",
        "testStrategy": "Manual validation by following setup steps with test Telegram account. Verify documentation accuracy and completeness. Test configuration examples in actual config files.",
        "priority": "low",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Integration testing and validation",
        "description": "Perform end-to-end testing of Telegram notifications in full application context",
        "details": "Test complete integration: configure test Telegram bot, add to user config, run marketplace monitor with Telegram notifications enabled. Verify notifications are sent for matching listings, error handling works correctly, and existing notification systems remain unaffected. Test with various listing types and message lengths. Validate asyncio.run() pattern doesn't interfere with other application components.",
        "testStrategy": "Manual testing with live Telegram bot and test marketplace listings. Verify all notification features work end-to-end. Run full test suite to ensure no regressions in existing functionality. Test performance impact of asyncio.run() overhead.",
        "priority": "low",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-31T21:47:31.681Z",
      "updated": "2025-08-01T18:44:11.659Z",
      "description": "Tasks for master context"
    }
  }
}
