{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup TelegramNotificationConfig Tests and Basic Class Structure",
        "description": "Create comprehensive test suite for TelegramNotificationConfig class following TDD approach, then implement minimal class structure to pass tests",
        "details": "Following TDD red/green/refactor cycle: 1) Write failing tests for TelegramNotificationConfig class creation, inheritance from NotificationConfig, and basic field validation (telegram_bot_token, telegram_chat_id, message_format). 2) Create minimal TelegramNotificationConfig class with dataclass decorator inheriting from NotificationConfig to make tests pass. 3) Use pytest for testing framework, mock telegram.Bot class completely. Install python-telegram-bot using 'poetry add python-telegram-bot'. Ensure all fields are properly typed and validated. Default message_format to 'markdownv2'.",
        "testStrategy": "Write failing unit tests first for class instantiation, field validation, inheritance verification, and configuration parsing. Mock all external dependencies. Tests must fail before implementation begins.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Test Suite Creation for Class Instantiation",
            "description": "Create a test suite that verifies the correct instantiation of classes, ensuring constructors and initial states behave as expected.",
            "dependencies": [],
            "details": "Set up a test suite framework (e.g., JUnit) and write test cases that instantiate the target classes. Validate that objects are created without errors and initial fields have expected default values.\n<info added on 2025-07-07T01:58:01.113Z>\nCritical issue identified: TelegramNotificationConfig has multiple inheritance from both Pydantic BaseModel and PushNotificationConfig dataclass, creating a dependency on BaseConfig's required 'name' field. All test instantiations must be updated to include name parameter (e.g., TelegramNotificationConfig(name=\"test_config\", ...)) to avoid instantiation failures. This affects basic object creation tests and any mock objects used in validation testing.\n</info added on 2025-07-07T01:58:01.113Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Test Suite for Field Validation and Inheritance",
            "description": "Develop a test suite to validate field constraints and inheritance behavior in the class hierarchy.",
            "dependencies": [
              1
            ],
            "details": "Write tests that check field validation rules (e.g., type, range, nullability) and verify that subclasses correctly inherit and override fields and methods from superclasses. Include tests for polymorphic behavior if applicable.\n<info added on 2025-07-07T02:18:38.840Z>\nImplementation completed successfully with comprehensive test coverage. All 44 tests passing in telegram integration suite, including 11 new validation and inheritance tests. Field validation covers type constraints, range validation, nullability rules, and boundary conditions for all telegram-specific fields. Inheritance testing verifies proper method overrides, polymorphic behavior, and multiple inheritance resolution order. Integration with UserConfig and parent classes fully validated with clear error messaging.\n</info added on 2025-07-07T02:18:38.840Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Minimal Class Implementation and Dependency Setup",
            "description": "Implement the minimal class structure with inheritance and set up any required dependencies to support the test suites.",
            "dependencies": [],
            "details": "Create basic class definitions with necessary fields and inheritance relationships. Configure project dependencies and testing frameworks to enable running the test suites effectively.\n<info added on 2025-07-07T02:04:22.138Z>\nUserConfig class in src/ai_marketplace_monitor/user.py lines 21-26 currently inherits from EmailNotificationConfig, PushbulletNotificationConfig, PushoverNotificationConfig, NtfyNotificationConfig but is missing TelegramNotificationConfig inheritance. Need to add TelegramNotificationConfig import and include it in the inheritance list to make telegram fields available to UserConfig instances.\n</info added on 2025-07-07T02:04:22.138Z>\n<info added on 2025-07-07T02:05:24.749Z>\nMethod Resolution Order (MRO) conflict discovered in UserConfig inheritance chain. PushNotificationConfig.handle_message_format overrides TelegramNotificationConfig.handle_message_format due to inheritance order. PushNotificationConfig enforces default='plain_text' with allowed values ['plain_text', 'markdown', 'html'], while TelegramNotificationConfig requires default='markdownv2' with allowed values ['plain_text', 'markdown', 'markdownv2', 'html']. This creates incompatible field definitions when both classes are inherited. Solution options: 1) Reorder inheritance to prioritize TelegramNotificationConfig, 2) Create separate field definitions in UserConfig to override conflicts, or 3) Refactor base classes to use composition instead of multiple inheritance for notification configs.\n</info added on 2025-07-07T02:05:24.749Z>\n<info added on 2025-07-07T02:08:33.249Z>\nCOMPLETED on 2025-07-07: Successfully implemented the minimal class structure and dependency setup. Added TelegramNotificationConfig import to user.py:17 and included it in UserConfig inheritance chain (user.py:23-28). Resolved multiple inheritance conflicts by reordering inheritance to prioritize TelegramNotificationConfig first, fixing MRO conflicts that caused message_format to default to 'plain_text' instead of 'markdownv2'. Added python-telegram-bot dependency via poetry add. All 33 tests now pass (14 instantiation + 10 integration + 9 TOML tests) with proper field validation, required_fields checking, and inheritance behavior. No regressions in existing user-related tests. All linting and type checking passes. TelegramNotificationConfig is now fully integrated with UserConfig.\n</info added on 2025-07-07T02:08:33.249Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Basic Message Sending with TDD",
        "description": "Create test-driven implementation of send_message() method with synchronous Telegram API integration",
        "details": "Following TDD: 1) Write failing tests for send_message() method behavior including successful message delivery, bot token validation, and chat ID validation. 2) Implement send_message() method using asyncio.run() wrapper around telegram.Bot.send_message() to maintain synchronous interface. 3) Handle basic text messages first. Use try/except for telegram.error.NetworkError. Mock telegram.Bot completely in tests to avoid external API calls. Ensure method signature matches NotificationConfig base class interface.",
        "testStrategy": "Write failing tests for send_message() method covering successful sends, invalid tokens, invalid chat IDs, and network errors. Mock telegram.Bot.send_message() completely. Verify asyncio.run() wrapper maintains synchronous behavior.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Integrate TelegramNotificationConfig with UserConfig System",
        "description": "Add Telegram configuration to existing UserConfig inheritance chain and TOML configuration parsing",
        "details": "Following TDD: 1) Write failing tests for UserConfig integration including TOML parsing for [notification.telegram] section and inheritance chain validation. 2) Add TelegramNotificationConfig to UserConfig class inheritance. 3) Update configuration validation to handle telegram_bot_token and telegram_chat_id fields. 4) Ensure TOML parsing supports the schema: [notification.telegram] with telegram_bot_token, telegram_chat_id, and message_format fields. 5) Integrate with existing notification orchestration patterns in user.py.",
        "testStrategy": "Write failing tests for TOML configuration parsing, UserConfig inheritance integration, and configuration validation. Mock file system operations. Test invalid configurations trigger proper validation errors.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Message Formatting Support (MarkdownV2, HTML, Text)",
        "description": "Add support for multiple Telegram message formats with test-driven development",
        "details": "Following TDD: 1) Write failing tests for each format type (markdownv2, html, text) including proper escaping and formatting. 2) Implement format-specific message preparation in send_message() method. 3) Use telegram.Bot.send_message() with parse_mode parameter ('MarkdownV2', 'HTML', or None). 4) Handle MarkdownV2 special character escaping (_, *, [, ], (, ), ~, `, >, #, +, -, =, |, {, }, ., !). 5) Provide graceful degradation from markdownv2 to html to text on format errors. 6) Leverage existing notification content from base classes for consistent formatting.",
        "testStrategy": "Write failing tests for each format type, special character escaping, format fallback behavior, and invalid format handling. Mock telegram.Bot.send_message() and verify parse_mode parameter is set correctly.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Message Splitting for Long Content",
        "description": "Add automatic message chunking for content exceeding Telegram's 4096 character limit using TDD",
        "details": "Following TDD: 1) Write failing tests for message splitting logic including edge cases, word boundary splitting, and format preservation across chunks. 2) Implement message splitting function that chunks at word boundaries when possible, max 4096 characters per chunk. 3) Preserve formatting across chunks for MarkdownV2 and HTML. 4) Handle edge cases like single words longer than 4096 characters. 5) Send multiple messages sequentially using asyncio.run() for each chunk. 6) Maintain message order and add chunk indicators (1/3, 2/3, 3/3) if helpful.",
        "testStrategy": "Write failing tests for various message lengths, word boundary splitting, format preservation, single long words, and chunk ordering. Mock telegram.Bot.send_message() and verify multiple calls for long messages.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Error Handling and Retry Logic",
        "description": "Add comprehensive error handling with exponential backoff retry logic following TDD principles",
        "details": "Following TDD: 1) Write failing tests for retry behavior, network error handling, and exponential backoff timing. 2) Implement retry wrapper with exponential backoff (0.1s, 0.2s, 0.4s, 0.8s, 1.6s) for max 5 attempts. 3) Catch telegram.error.NetworkError, telegram.error.RetryAfter, and other transient errors. 4) Use time.sleep() for backoff delays. 5) Log retry attempts using existing logging infrastructure. 6) Return appropriate NotificationStatus enum values. 7) Handle rate limiting with telegram.error.RetryAfter exception.",
        "testStrategy": "Write failing tests for retry behavior, exponential backoff timing, different error types, max retry limits, and logging. Mock telegram.Bot.send_message() to simulate various error conditions and verify retry logic.",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Create Comprehensive Unit Test Suite",
        "description": "Expand test coverage for all edge cases, error scenarios, and integration points",
        "details": "Following TDD principles established in previous tasks: 1) Add comprehensive test cases for all edge scenarios including invalid configurations, malformed messages, network failures, and rate limiting. 2) Test integration with existing notification system end-to-end. 3) Mock all external dependencies including telegram.Bot, file system operations, and network calls. 4) Use pytest fixtures for common test setup. 5) Achieve >90% code coverage. 6) Test message splitting with various content types and lengths. 7) Validate retry logic with different failure scenarios.",
        "testStrategy": "Comprehensive unit test suite covering all functionality, edge cases, error conditions, and integration points. Mock all external dependencies. Use pytest with coverage reporting. Verify all tests pass consistently.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Add Configuration Validation and Error Handling",
        "description": "Implement robust configuration validation with clear error messages and fallback behavior",
        "details": "Following TDD: 1) Write failing tests for configuration validation including invalid bot tokens, malformed chat IDs, and missing required fields. 2) Implement validation for telegram_bot_token format (should start with number:). 3) Validate telegram_chat_id format (numeric or @channel_name). 4) Add clear error messages for configuration issues. 5) Implement validation during UserConfig initialization. 6) Use existing validation patterns from other notification types. 7) Handle missing optional fields gracefully (use defaults).",
        "testStrategy": "Write failing tests for various invalid configurations, validation error messages, and graceful handling of missing optional fields. Verify validation occurs at appropriate initialization points.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Integrate with Existing Notification Pipeline",
        "description": "Complete integration with main notification orchestration system and ensure compatibility",
        "details": "Following TDD: 1) Write failing tests for notification pipeline integration including message routing, status tracking, and error propagation. 2) Ensure TelegramNotificationConfig works seamlessly with existing notification orchestration in user.py. 3) Test integration with NotificationStatus enum and error handling patterns. 4) Verify compatibility with existing notification content generation. 5) Ensure proper logging and monitoring integration. 6) Test notification delivery alongside other notification types (email, Pushover, etc.).",
        "testStrategy": "Write failing tests for end-to-end notification pipeline integration, status tracking, and multi-notification-type scenarios. Mock all external services and verify proper integration behavior.",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Documentation and Final Testing",
        "description": "Create user documentation, configuration examples, and perform final integration testing",
        "details": "1) Create comprehensive documentation for Telegram notification setup including bot creation, chat ID discovery, and configuration examples. 2) Add TOML configuration examples to existing documentation. 3) Create troubleshooting guide for common issues (invalid tokens, chat permissions, rate limiting). 4) Update main project documentation to include Telegram as supported notification type. 5) Perform final end-to-end testing with real Telegram bot (optional, for manual verification). 6) Ensure all tests pass and code coverage meets project standards.",
        "testStrategy": "Document all functionality with clear examples. Verify documentation accuracy through manual testing. Ensure all automated tests pass consistently and maintain high code coverage.",
        "priority": "low",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-07T01:53:45.723Z",
      "updated": "2025-07-07T02:18:55.753Z",
      "description": "Tasks for master context"
    }
  }
}
